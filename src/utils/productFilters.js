/**
 * Utility functions for product filtering and sorting
 */

/**
 * Filter products by price range
 */
export const filterByPriceRange = (products, priceRange) => {
  if (priceRange === 'all') return products;

  return products.filter(product => {
    let price = 0;
    if (typeof product.price === 'number') {
      price = product.price;
    } else if (typeof product.price === 'string') {
      price = parseFloat(product.price.replace(/[^0-9.]/g, ''));
    } else if (product.price && product.price.$numberDecimal) {
      price = parseFloat(product.price.$numberDecimal);
    } else {
      price = parseFloat(String(product.price).replace(/[^0-9.]/g, ''));
    }

    if (isNaN(price)) price = 0;

    switch (priceRange) {
      case '0-1200':
        return price >= 0 && price <= 1200;
      case '1200-2400':
        return price > 1200 && price <= 2400;
      case '2400-3600':
        return price > 2400 && price <= 3600;
      case '3600+':
        return price > 3600;
      default:
        return true;
    }
  });
};

/**
 * Filter products by brands
 */
export const filterByBrands = (products, selectedBrands) => {
  if (selectedBrands.length === 0) return products;

  return products.filter(product =>
    selectedBrands.includes(product.brand)
  );
};

/**
 * Filter products by colors
 */
export const filterByColors = (products, selectedColors) => {
  if (selectedColors.length === 0) return products;

  return products.filter(product => {
    let productColors = product.colors;

    // Handle JSON string from backend
    if (typeof productColors === 'string') {
      try {
        productColors = JSON.parse(productColors);
      } catch (e) {
        productColors = [];
      }
    }

    if (Array.isArray(productColors) && productColors.length > 0) {
      // Check if any selected color is in the product's color list
      // Using case-insensitive comparison for safety
      return productColors.some(color =>
        selectedColors.some(selected => selected.toLowerCase() === color.toLowerCase())
      );
    }
    return false; // If no colors, it doesn't match a color filter
  });
};

export const filterByCategory = (products, categorySlug) => {
  if (!categorySlug) return products;

  return products.filter(product => {
    // Handle both string category and object category from backend
    const slug = product.category?.slug ||
      (typeof product.category === 'string' ? product.category.toLowerCase().replace(/\s+/g, '-') : '');

    return slug === categorySlug;
  });
};

/**
 * Sort products
 */
export const sortProducts = (products, sortBy) => {
  const sorted = [...products];

  switch (sortBy) {
    case 'price-low':
      sorted.sort((a, b) => {
        const getPrice = (p) => {
          if (typeof p === 'number') return p;
          if (typeof p === 'string') return parseFloat(p.replace(/[^0-9.]/g, '')) || 0;
          if (p && p.$numberDecimal) return parseFloat(p.$numberDecimal) || 0;
          return parseFloat(String(p).replace(/[^0-9.]/g, '')) || 0;
        };
        return getPrice(a.price) - getPrice(b.price);
      });
      break;
    case 'price-high':
      sorted.sort((a, b) => {
        const getPrice = (p) => {
          if (typeof p === 'number') return p;
          if (typeof p === 'string') return parseFloat(p.replace(/[^0-9.]/g, '')) || 0;
          if (p && p.$numberDecimal) return parseFloat(p.$numberDecimal) || 0;
          return parseFloat(String(p).replace(/[^0-9.]/g, '')) || 0;
        };
        return getPrice(b.price) - getPrice(a.price);
      });
      break;
    case 'newness':
      sorted.reverse();
      break;
    case 'popularity':
    case 'rating':
    default:
      // Keep original order
      break;
  }

  return sorted;
};

/**
 * Apply all filters and sorting to products
 */
export const applyFilters = (products, filters, category = null) => {
  let filtered = category
    ? filterByCategory(products, category)
    : [...products];

  filtered = filterByPriceRange(filtered, filters.priceRange);
  filtered = filterByBrands(filtered, filters.selectedBrands);
  filtered = filterByColors(filtered, filters.selectedColors);
  filtered = sortProducts(filtered, filters.sortBy);

  return filtered;
};

/**
 * Get price range display text
 */
export const getPriceRangeText = (priceRange) => {
  const rangeMap = {
    '0-1200': '0.00 - 1,200 EGP',
    '1200-2400': '1,200 - 2,400 EGP',
    '2400-3600': '2,400 - 3,600 EGP',
    '3600+': '3,600 EGP +',
  };
  return rangeMap[priceRange] || priceRange;
};

